{"0": {
    "doc": "About",
    "title": "About",
    "content": "Publications . M. Pitsikalis, A. Lisitsa, and S. Luo, “Representation and Processing of Instantaneous and Durative Temporal Phenomena,” in Logic-Based Program Synthesis and Transformation, vol. 13290, E. De Angelis and W. Vanhoof, Eds. Cham: Springer International Publishing, 2022, pp. 135–156. doi: 10.1007/978-3-030-98869-2_8. Disclaimer . While Phenesthe has undergone through testing, it’s still under development. Therefore some bugs may exist :) . License . This project is licensed under the terms of the GNU General Public License version 3.0 . ",
    "url": "/about/",
    "relUrl": "/about/"
  },"1": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": "An overview of the architecture of phenesthe is presented in the figure below. Input information . The input is of two kinds; static and dynamic information. | Static input refers to a set of phenomena definitions written in the language of this paper along with a declaration of the expected input phenomena. Static information may also include atemporal information such as predicates storing information regarding the elements of a specific use-case. | Dynamic input refers to the input stream which contains input phenomena associated with some temporal information. The phenomena definitions and declarations pass through a transformation step, during which they are transformed into a standard Prolog language representation. Additionally, the dependencies between phenomena are computed and a valid evaluation order is produced (see “Dependency Graph Computation” in the above Figure). | . Temporal querying . When the transformation and the computation of the evaluation order of the user defined phenomena is complete, processing of the input stream is able to commence. Processing of the input happens in the form of temporal queries, on temporal windows of the input stream, at equally distanced times specified by the value of step. During a temporal query the instants and the intervals at which user defined phenomena are true or hold are computed and printed in the output stream. Additionally, during each temporal query redundant information is discarded and non-redundant information is retained until classified otherwise via the redundancy handling mechanism. Therefore, for stream processing the user is responsible for selecting the following values: . | Step: The distance between temporal queries. At the moment, variable step size (i.e., performing temporal queries on unequally distanced times) is not supported. | Window size: The size of the window to be used in each temporal query. Each window is a subset of the input stream. | . Dependency aware parallelisation . User defined phenomena can be processed in a sequential manner by following the evaluation order produced by the topological sort of the directed acyclic graph they form. An example dependency graph is shown below for the YSP example. However, if possible they can also be executed in parallel. In Phenesthe we implement dependency-aware parallelisation whereby phenomena definitions that have no pending dependencies are processed in parallel via a Master-Worker paradigm. Here, the master checks for phenomena definitions that do not have any unmet dependencies and inserts them in the processing queue. Workers remove phenomena definitions from the processing queue, process them, and notify the master as soon as they complete. This process goes on until all the user defined phenomena are processed. By default dependency aware parallelisation is enabled. If required, dependency aware parallelisation can be turned off by setting the following: . phe_setval(multithreading,0). ",
    "url": "/docs/documentation/architecture.html",
    "relUrl": "/docs/documentation/architecture.html"
  },"2": {
    "doc": "Input & User Phenomena",
    "title": "Phenomena",
    "content": "Phenomena in Phenesthe can be either user defined or input. For each application a definition file must created that contains the user definitions and the input phenomena declarations. ",
    "url": "/docs/documentation/definitions.html#phenomena",
    "relUrl": "/docs/documentation/definitions.html#phenomena"
  },"3": {
    "doc": "Input & User Phenomena",
    "title": "User defined phenomena",
    "content": "Definitions of phenomena in Phenesthe can be of three types: . | Event definitions | State definitions | Dynamic temporal phenomena definitions | . Events . Events are defined using instant formulae of the language and via the use of the event_phenomenon keyword. An example definition from the Alice and Bob sample is the following: . %gain when picking up and not dropping event_phenomenon gain(Person) := pickup(Person, _Object) and tnot drop(Person,_). States . States are defined using disjoint interval formulae of the language and the state_phenomenon keyword. An example from the maritime domain is the following: . dynamic_phenomenon fishing_trip(V,PA,FA,PB):= (end(moored(V,PA)) aand vessel_type(V,fishing)) before ((underway(V) contains in_fishing_area(V,FA)) before start(moored(V,PB))). Dynamic temporal phenomena . Dynamic temporal phenomena are defined using non-disjoint interval formulae of the language and the dynamic_phenomenon keyword. An example from the meal preparation scenario is the following: . dynamic_phenomenon mealPrep(P) := stirfryPrep(P) finishes steaksPrep(P). ",
    "url": "/docs/documentation/definitions.html#user-defined-phenomena",
    "relUrl": "/docs/documentation/definitions.html#user-defined-phenomena"
  },"4": {
    "doc": "Input & User Phenomena",
    "title": "Input phenomena",
    "content": "Input phenomena declarations should have the following form: . | Events input_phenomenon(event_name(_,...,_),event). | States input_phenomenon(state_name(_,...,_),state). | Dynamic temporal phenomena input_phenomenon(dyn_temp_phe_name(_,...,_),dynamic). | . ",
    "url": "/docs/documentation/definitions.html#input-phenomena",
    "relUrl": "/docs/documentation/definitions.html#input-phenomena"
  },"5": {
    "doc": "Input & User Phenomena",
    "title": "Input & User Phenomena",
    "content": " ",
    "url": "/docs/documentation/definitions.html",
    "relUrl": "/docs/documentation/definitions.html"
  },"6": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "Getting Started . In this section you will find the instructions for running a minimal example application of Phenesthe. For more complicated applications please read the documentation section. Running Phenesthe on the included ‘Alice &amp; Bob’ sample . The samples/alice_and_bob/ folder includes an example usage of Phenesthe. The definitions.prolog contains definitions of temporal phenomena, the narrative.prolog contains the input phenomena i.e., the input and run.prolog loads Phenesthe and preprocesses the phenomena definitions. | Have a look at the phenomena definitions in definitions.prolog and the narrative at narrative.prolog in the samples/alice_and_bob folder. | Load run.prolog in SWI-Prolog. Calling query(5) loads the input phenomena that arrived until ‘5’ and performs a recognition query given that time is ‘5’. cd samples/alice_and_bob swipl -l run.prolog ?- query(5). % asserts the input (until t=5) and performs recognition of phenomena at t=5 . | In order to print the recognised events you will have to use the event_instants(X,T) predicate. Calling event_instants(X,T) will print a user defined event (X) and the instant list (T) at which it’s true. For example the event unchanged(bob) is true at the instant(s) included in list T=[3]. ?- event_instants(X,T). % outputs the recognised events X = unchanged(bob), T = [3] ; ... | state_intervals(X,I) outputs user defined states (X) and the interval list (I) at which they hold. For example the state possess(alice,wallet) holds for the interval(s) included in list I = [[4, inf]]. ?- state_intervals(X,I). % outputs the recognised states X = possess(alice, wallet), I = [[4, inf]] ; ... | dynamic_phenomena_intervals(X,I) outputs the user defined dynamic temporal phenomena (X) and the intervals (I) at which they hold. For example the state drops_objects_when_hungry(bob) holds for the interval(s) included in list I = [[1, inf]]. ?- dynamic_phenomenon_intervals(X,I). % outputs the recognised dynamic phenomena X = drops_objects_when_hungry(bob), I = [[1, inf]]. | . ",
    "url": "/getting-started/",
    "relUrl": "/getting-started/"
  },"7": {
    "doc": "Documentation",
    "title": "Documentation",
    "content": " ",
    "url": "/docs/documentation/",
    "relUrl": "/docs/documentation/"
  },"8": {
    "doc": "Installation",
    "title": "Installation",
    "content": "Installation . Running Phenesthe requires a prolog installation. Specifically it has been tested under SWI-Prolog 7.6.4. You can download the latest version of Phenesthe using the command below: . git clone https://github.com/manospits/Phenesthe.git . Once downloaded, and provided that you have SWI-Prolog installed, Phenesthe is ready to run. You can confirm that you have a working version of Phenesthe by navigating to the unit_tests folder and run the unit tests. cd unit_tests ./run_tests.sh . ",
    "url": "/installation/",
    "relUrl": "/installation/"
  },"9": {
    "doc": "Language",
    "title": "Language",
    "content": "The language of Phenesthe allows the definition of temporal phenomena. A temporal phenomenon may be an event, a state or a dynamic temporal phenomenon. Events are true in instants of time, states hold in disjoint intervals and dynamic temporal phenomena may hold in possibly non disjoint intervals. Moreover, the language of phenesthe allows the declaration of the phenomena of the input stream. Grammar . The grammar of the language is present below in EBNF: . definitions = eventDefinition | stateDefinition | dynamicDefinition; eventDefinition = \"event_phenomenon\" event \":=\" instantExpression \".\"; stateDefinition = \"state_phenomenon\" state \":=\" intervalOperation \".\"; dynamicDefinition = \"dynamic_phenomenon\" dynamic \":=\" intervalRelation \".\"; event = eventName(...); state = stateName(...); dynamic = dynamicPhenomenonName(...); temporalExpression = instantExpression | intervalExpression ; instantExpression = \"(\"instantExpresstion\")\"| \"tnot\" instantExpression | instantExpression (\"and\"|\"or\") instantExpression | instantExpression \"in\" intervalOperation | instantExpression (\"@&lt;\"|\"@&gt;=\"|\"@=\") number | instantExpression \"aand\" atemporalPrologExpression | startEndOp | event; intervalExpression = intervalOperation | intervalRelation; intervalOperation = intervalOperation (\"union\"|\"intersection\"|\"complement\") intervalOperation | instantExpression \"~&gt;\" instantExpression | intervalOperation \"aand\" atemporalPrologExpression | \"(\"intervalOperation\")\"| state; intervalRelation = temporalExpression \"before\" temporalExpression | intervalExpression \"overlaps\" intervalExpression | intervalExpression \"meets\" intervalExpression | temporalExpression \"finishes\" intervalExpression | temporalExpression \"starts\" intervalExpression | intervalExpression \"contains\" temporalExpression | intervalExpression \"equals\" intervalExpression | intervalRelation \"aand\" atemporalPrologExpression |\"(\"intervalRelation\")\" | dynamic; startEndOp ::= (\"start\"|\"end\")\"(\"intervalOperation\")\"; . Semantics . In short, the formulae of the language of Phenesthe, are divided into three categories instant formulae, disjoint interval formulae, and non-disjoint interval formulae. Each of the aforementioned formulae categories is used for defining events, states and dynamic temporal phenomena. Below the semantics of each formulae category are presented with examples. Instant formulae . Instant formulae describe happenings that are true in instants of time. | Name | Formula | Description | . | Conjunction | fa and fb | True at instants where both fa and fb occur. | . | Disjunction | fa or fb | True at instants where either fa or fb occurs. | . | Negation | tnot fa | True at instants where fa does not occur. | . | Start | start(fa) | True at the instant fa starts holding. | . | End | end(fa) | True at the instant fa stops holding. | . | Inclusion | fa in fb | True if fa occurs while fb holds. | . Instant formulae examples . | A formula that is true when a person either drops or pickups an object. drop(Person, ObjectA) or pickup(Person, ObjectB). | A formula that describes that in order for a person (P) to shoot with gun (G), the gun must be loaded. shoot(G,P) in loaded(G). | . Disjoint interval formulae . Disjoint interval formulae describe durative states that hold in disjoint intervals. | Name | Formula | Description | . | Maximal range operator | fa ~&gt; fb | Holds when fa occurs, and continues to hold unless fb occurs. | . | Temporal union | fa union fb | Holds when either fa or fb holds. | . | Temporal intersection | fa intersection fb | Holds when both fa and fb hold. | . | Temporal complement | fa complement fb | Holds when fa holds but fb does not hold. | . | Constrained iteration | fa [&lt;,=,&gt;=]@ N | Holds when `fa’ occurs at times with contiguous temporal distance (t1-t0) [&lt;,=,&gt;=] N. | . | Filtering | filter(fb,f(...)) | Filter intervals at which fb holds by applying function f on their individual size. | . Disjoint interval formulae examples . | A formula the describes the time intervals where a person has a gain but not loss in the meantime. gain(Person) ~&gt; loss(Person) . | A formula that holds when a vessel is both at a port and stopped. stopped(V) intersection in_port(V,P) . | A formula that holds when vegetables are stirred at most every 30 seconds. stir(vegetables) &lt;@ 30 . | . Non-disjoint interval formulae . Non-disjoint interval formulae describe the temporal arrangement of temporal phenomena. | Name | Formula | Description | . | Before | fa before fb | fa occurs (holds), before fb occurs (holds) and they are contiguous. | . | Overlaps | fa overlaps fb | fa starts holding, then fb starts holding, next fa stops holding, finally fb stops holding. | . | Meets | fa meets fb | Holds when fb starts holding when fa stops holding. | . | Finishes | fa finishes fb | Holds when fb holds, and fa occurs when fb stops holding or fa starts holding after fb starts and finishes at the same time as fb. | . | Starts | fa starts fb | Holds when fb holds, and fa occurs when fb starts holding or fb starts holding when fa starts but stops holding earlier than fb. | . | Contains | fa contains fb | Holds when fa holds and fb occurs (holds) during fa. | . | Equals | fa equals fb | Holds when both fa and fb hold at the same time. | . Non-disjoint interval formulae examples . | A formula that describes a vessel trip (end of being moored, followed by being underway, the finally being moored again). end(moored(V,PA)) before (underway(V) before start(moored(V,PB))). | The cooking process of fried then oven baked steaks. filter((filter((cooking(P,stove,steaks)),greater(120))),less(180)) before filter((filter((cooking(P,oven,steaks)),greater(480))),less(600)) . | . ",
    "url": "/docs/documentation/language.html",
    "relUrl": "/docs/documentation/language.html"
  },"10": {
    "doc": "Stream processing",
    "title": "Stream processing",
    "content": "Phenesthe is a tool that allows the detection of temporal phenomena on streams. Currently it can handle two types of streams: file streams and UNIX pipe streams. In this section the input format as well as the methodology for processing both types is described. Input stream format . When using Phenesthe for stream processing, the input stream should contain entries as follows: . | Input events input_event_instant(event_name(arg_1,...,arg_n),T) . arg_1,...,arg_n are atemporal values, while T is the occurrence time. | Input states input_state_interval(state_name(arg_1,...,arg_n),[Ts,Te]) . arg_1,...,arg_n are atemporal values, while [Ts,Te] is a strict interval (i.e., Ts &lt; Te) denoting the time period where state_name/n holds. | Input dynamic temporal phenomena input_dynamic_phenomenon_interval(dyn_temp_phe_name(arg_1,...,arg_n),[Ts,Te]) . arg_1,...,arg_n are atemporal values, while [Ts,Te] is a strict interval (i.e., Ts &lt; Te) denoting the time period where arg_1,…,arg_n/n holds. | . The input should be ordered via the ‘&lt;’ for instants and then for intervals first on the starting times and then on the ending times. File stream processing . Processing a file stream (a text file) is allowed via the following predicate: . queries_on_fstream(InputFile,LogFile,ResultsFile,Start,End,Step,Window) . Where the arguments denote the following: . | InputFile: Name of the input file. | LogFile: Name of the log file (statistics for each temporal query). | ResultsFile: Printed instants and intervals at which user defined phenomena are true hold. | Start: Timestamp to start processing. | End: Timestamp to end processing. | Step: Window sliding step. | Window: Window size. Phenesthe will start processing phenomena based on the start timestamp and it will stop based on the end timestamp or the EOF. | . Stream (general) processing . Currently stream processing in Phenesthe is allowed via the use of named UNIX pipe streams. Pipes can be created via the use of the mkfifo command. The predicate used for processing these pipe streams is the following: . queries_on_stream(PipeName,LogFile,ResultsFile,Step,Window) . Where the arguments denote the following: . | PipeName: Name of the pipe. | LogFile: Name of the log file (statistics for each temporal query). | ResultsFile: Printed instants and intervals at which user defined phenomena are true hold. | Step: Window sliding step. | Window: Window size. | . Stream processing here will stop when the pipe is closed (by force) or an EOF is read. Complete example . Therefore to use Phenesthe for stream processing the following steps must be taken. | Initial setup: load Phenesthe, definitions of phenomena and any static information. % Maritime example :-['../../phenesthe.prolog']. % load the maritime definitions :-['./definitions.prolog']. % load vessel types :-['./vessel_types.prolog']. | Definitions preprocessing: Here the definitions are transformed into prolog code and their dependencies and evaluation order is computed. % Maritime example % preprocess phenomena definitions (transform them, find evaluation order, etc.) :-preprocess_phenomena_definitions. | Temporal querying: Call the appropriate stream processing predicate as follows: % Maritime example queries_on_fstream('BREST_phenesthe.input','logs/log_1_3600.csv','results/results_1_3600.out',1443650401,1444255201,3600,3600). | . ",
    "url": "/docs/documentation/stream.html",
    "relUrl": "/docs/documentation/stream.html"
  }
}
